{"version":3,"sources":["../src/registry/schema.ts","../src/registry/api.ts","../src/registry/utils.ts","../src/utils/resolve-import.ts","../src/utils/get-config.ts","../src/utils/get-project-info.ts","../src/utils/frameworks.ts","../src/utils/get-package-info.ts","../src/utils/highlighter.ts","../src/utils/logger.ts","../src/utils/handle-error.ts","../src/utils/updaters/update-tailwind-config.ts","../src/utils/spinner.ts"],"names":["z","registryItemTypeSchema","registryItemFileSchema","registryItemTailwindSchema","registryItemCssVarsSchema","registryItemCssSchema","registryItemSchema","registrySchema","registryIndexSchema","stylesSchema","iconsSchema","registryBaseColorSchema","registryResolvedItemsTreeSchema","fs","homedir","path","tmpdir","createMatchPath","resolveImport","importPath","config","Project","ScriptKind","loadConfig","FILE_EXTENSIONS_FOR_LOOKUP","FILE_PATH_SKIP_LIST","DEPENDENCY_SKIP_LIST","project","getDependencyFromModuleSpecifier","moduleSpecifier","pattern","parts","recursivelyResolveFileImports","filePath","projectInfo","processedFiles","resolvedFilePath","relativeRegistryFilePath","fileExtension","content","tempFile","createTempSourceFile","sourceFile","tsConfig","files","dependencies","fileType","determineFileType","originalFile","importStatements","importStatement","isRelativeImport","dependency","probableImportFilePath","ext","pathWithExt","nestedRelativeRegistryFilePath","file","nestedResults","dep","uniqueFiles","filename","dir","isUrl","isLocalFile","FRAMEWORKS","getPackageInfo","cwd","shouldThrow","packageJsonPath","fg","PROJECT_SHARED_IGNORE","TS_CONFIG_SCHEMA","getProjectInfo","configFiles","isSrcDir","isTsx","tailwindConfigFile","tailwindCssFile","tailwindVersion","aliasPrefix","packageJson","isTypeScriptProject","getTailwindConfigFile","getTailwindCssFile","getTailwindVersion","getTsConfigAliasPrefix","isUsingAppDir","type","appConfig","packageInfo","getConfig","needle","contents","alias","paths","getProjectConfig","defaultProjectInfo","existingConfig","resolveConfigPaths","getProjectTailwindVersionFromConfig","cyan","green","red","yellow","highlighter","cosmiconfig","DEFAULT_COMPONENTS","DEFAULT_UTILS","DEFAULT_TAILWIND_CSS","DEFAULT_TAILWIND_CONFIG","explorer","rawConfigSchema","configSchema","workspaceConfigSchema","getRawConfig","configResult","componentPath","getWorkspaceConfig","resolvedAliases","key","isAliasKey","resolvedPath","packageRoot","findPackageRoot","result","commonRoot","findCommonRoot","relativePath","matchingPackageRoot","pkgPath","pkgDir","parts1","parts2","commonParts","i","getTargetStyleFromConfig","fallback","logger","args","handleError","error","value","ora","spinner","text","options","deepmerge","objectToString","QuoteKind","SyntaxKind","updateTailwindConfig","tailwindConfig","tailwindFileRelativePath","tailwindSpinner","raw","output","transformTailwindConfig","input","_createSourceFile","configObject","node","property","quoteChar","_getQuoteChar","addTailwindConfigProperty","plugin","addTailwindConfigPlugin","addTailwindConfigTheme","existingProperty","newProperty","initializer","newValue","initializerText","element","theme","nestSpreadProperties","themeInitializer","themeObjectString","themeObject","parseObjectLiteral","dst","src","resultString","unnestSpreadProperties","existingPlugins","obj","properties","prop","spreadAssignment","spreadText","nestSpreadElements","arr","elements","j","propAssignment","unsetSpreadElements","spreadTest","objectLiteralString","statement","parseObjectLiteralExpression","name","parseArrayLiteralExpression","parseValue","buildTailwindThemeColorsFromCssVars","cssVars","colorName","subType","HttpsProxyAgent","fetch","REGISTRY_URL","agent","registryCache","BASE_COLORS","getRegistryIndex","fetchRegistry","getRegistryStyles","getRegistryIcons","getRegistryItem","style","getLocalRegistryItem","expandedPath","parsed","getRegistryBaseColors","getRegistryBaseColor","baseColor","resolveTree","index","names","tree","entry","component","self","c","fetchTree","item","getItemTargetPath","override","parent","url","getRegistryUrl","fetchPromise","response","errorMessages","message","clearRegistryCache","resolveDependenciesRecursively","visited","items","registryNames","nested","registryResolveItemsTree","localFiles","urls","payload","allDependencies","localFile","dependencyItems","dependencyRegistryNames","allRegistryNames","uniqueRegistryNames","registryItems","resolveRegistryItems","registryPayload","registryGetTheme","a","b","tailwind","css","docs","resolveRegistryDependencies","registryDependencies","itemRegistryDependencies","getRegistryTypeAliasMap","getRegistryParentMap","map"],"mappings":"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","sourcesContent":["import { z } from \"zod\"\n\n// Note: if you edit the schema here, you must also edit the schema in the\n// apps/www/public/schema/registry-item.json file.\n\nexport const registryItemTypeSchema = z.enum([\n  \"registry:lib\",\n  \"registry:block\",\n  \"registry:component\",\n  \"registry:ui\",\n  \"registry:hook\",\n  \"registry:page\",\n  \"registry:file\",\n  \"registry:theme\",\n  \"registry:style\",\n\n  // Internal use only\n  \"registry:example\",\n  \"registry:internal\",\n])\n\nexport const registryItemFileSchema = z.discriminatedUnion(\"type\", [\n  // Target is required for registry:file and registry:page\n  z.object({\n    path: z.string(),\n    content: z.string().optional(),\n    type: z.enum([\"registry:file\", \"registry:page\"]),\n    target: z.string(),\n  }),\n  z.object({\n    path: z.string(),\n    content: z.string().optional(),\n    type: registryItemTypeSchema.exclude([\"registry:file\", \"registry:page\"]),\n    target: z.string().optional(),\n  }),\n])\n\nexport const registryItemTailwindSchema = z.object({\n  config: z\n    .object({\n      content: z.array(z.string()).optional(),\n      theme: z.record(z.string(), z.any()).optional(),\n      plugins: z.array(z.string()).optional(),\n    })\n    .optional(),\n})\n\nexport const registryItemCssVarsSchema = z.object({\n  theme: z.record(z.string(), z.string()).optional(),\n  light: z.record(z.string(), z.string()).optional(),\n  dark: z.record(z.string(), z.string()).optional(),\n})\n\nexport const registryItemCssSchema = z.record(\n  z.string(),\n  z.lazy(() =>\n    z.union([\n      z.string(),\n      z.record(\n        z.string(),\n        z.union([z.string(), z.record(z.string(), z.string())])\n      ),\n    ])\n  )\n)\n\nexport const registryItemSchema = z.object({\n  $schema: z.string().optional(),\n  extends: z.string().optional(),\n  name: z.string(),\n  type: registryItemTypeSchema,\n  title: z.string().optional(),\n  author: z.string().min(2).optional(),\n  description: z.string().optional(),\n  dependencies: z.array(z.string()).optional(),\n  devDependencies: z.array(z.string()).optional(),\n  registryDependencies: z.array(z.string()).optional(),\n  files: z.array(registryItemFileSchema).optional(),\n  tailwind: registryItemTailwindSchema.optional(),\n  cssVars: registryItemCssVarsSchema.optional(),\n  css: registryItemCssSchema.optional(),\n  meta: z.record(z.string(), z.any()).optional(),\n  docs: z.string().optional(),\n  categories: z.array(z.string()).optional(),\n})\n\nexport type RegistryItem = z.infer<typeof registryItemSchema>\n\nexport const registrySchema = z.object({\n  name: z.string(),\n  homepage: z.string(),\n  items: z.array(registryItemSchema),\n})\n\nexport type Registry = z.infer<typeof registrySchema>\n\nexport const registryIndexSchema = z.array(registryItemSchema)\n\nexport const stylesSchema = z.array(\n  z.object({\n    name: z.string(),\n    label: z.string(),\n  })\n)\n\nexport const iconsSchema = z.record(\n  z.string(),\n  z.record(z.string(), z.string())\n)\n\nexport const registryBaseColorSchema = z.object({\n  inlineColors: z.object({\n    light: z.record(z.string(), z.string()),\n    dark: z.record(z.string(), z.string()),\n  }),\n  cssVars: registryItemCssVarsSchema,\n  cssVarsV4: registryItemCssVarsSchema.optional(),\n  inlineColorsTemplate: z.string(),\n  cssVarsTemplate: z.string(),\n})\n\nexport const registryResolvedItemsTreeSchema = registryItemSchema.pick({\n  dependencies: true,\n  devDependencies: true,\n  files: true,\n  tailwind: true,\n  cssVars: true,\n  css: true,\n  docs: true,\n})\n","import { promises as fs } from \"fs\"\nimport { homedir } from \"os\"\nimport path from \"path\"\nimport { isLocalFile } from \"@/src/registry/utils\"\nimport { Config, getTargetStyleFromConfig } from \"@/src/utils/get-config\"\nimport { getProjectTailwindVersionFromConfig } from \"@/src/utils/get-project-info\"\nimport { handleError } from \"@/src/utils/handle-error\"\nimport { highlighter } from \"@/src/utils/highlighter\"\nimport { logger } from \"@/src/utils/logger\"\nimport { buildTailwindThemeColorsFromCssVars } from \"@/src/utils/updaters/update-tailwind-config\"\nimport deepmerge from \"deepmerge\"\nimport { HttpsProxyAgent } from \"https-proxy-agent\"\nimport fetch from \"node-fetch\"\nimport { z } from \"zod\"\n\nimport {\n  iconsSchema,\n  registryBaseColorSchema,\n  registryIndexSchema,\n  registryItemSchema,\n  registryResolvedItemsTreeSchema,\n  stylesSchema,\n} from \"./schema\"\n\nconst REGISTRY_URL = process.env.REGISTRY_URL ?? \"https://ui.shadcn.com/r\"\n\nconst agent = process.env.https_proxy\n  ? new HttpsProxyAgent(process.env.https_proxy)\n  : undefined\n\nconst registryCache = new Map<string, Promise<any>>()\n\nexport const BASE_COLORS = [\n  {\n    name: \"neutral\",\n    label: \"Neutral\",\n  },\n  {\n    name: \"gray\",\n    label: \"Gray\",\n  },\n  {\n    name: \"zinc\",\n    label: \"Zinc\",\n  },\n  {\n    name: \"stone\",\n    label: \"Stone\",\n  },\n  {\n    name: \"slate\",\n    label: \"Slate\",\n  },\n] as const\n\nexport async function getRegistryIndex() {\n  try {\n    const [result] = await fetchRegistry([\"index.json\"])\n\n    return registryIndexSchema.parse(result)\n  } catch (error) {\n    logger.error(\"\\n\")\n    handleError(error)\n  }\n}\n\nexport async function getRegistryStyles() {\n  try {\n    const [result] = await fetchRegistry([\"styles/index.json\"])\n\n    return stylesSchema.parse(result)\n  } catch (error) {\n    logger.error(\"\\n\")\n    handleError(error)\n    return []\n  }\n}\n\nexport async function getRegistryIcons() {\n  try {\n    const [result] = await fetchRegistry([\"icons/index.json\"])\n    return iconsSchema.parse(result)\n  } catch (error) {\n    handleError(error)\n    return {}\n  }\n}\n\nexport async function getRegistryItem(name: string, style: string) {\n  try {\n    // Handle local file paths\n    if (isLocalFile(name)) {\n      return await getLocalRegistryItem(name)\n    }\n\n    // Handle URLs and component names\n    const [result] = await fetchRegistry([\n      isUrl(name) ? name : `styles/${style}/${name}.json`,\n    ])\n\n    return registryItemSchema.parse(result)\n  } catch (error) {\n    logger.break()\n    handleError(error)\n    return null\n  }\n}\n\nasync function getLocalRegistryItem(filePath: string) {\n  try {\n    // Handle tilde expansion for home directory\n    let expandedPath = filePath\n    if (filePath.startsWith(\"~/\")) {\n      expandedPath = path.join(homedir(), filePath.slice(2))\n    }\n\n    const resolvedPath = path.resolve(expandedPath)\n    const content = await fs.readFile(resolvedPath, \"utf8\")\n    const parsed = JSON.parse(content)\n\n    return registryItemSchema.parse(parsed)\n  } catch (error) {\n    logger.error(`Failed to read local registry file: ${filePath}`)\n    handleError(error)\n    return null\n  }\n}\n\nexport async function getRegistryBaseColors() {\n  return BASE_COLORS\n}\n\nexport async function getRegistryBaseColor(baseColor: string) {\n  try {\n    const [result] = await fetchRegistry([`colors/${baseColor}.json`])\n\n    return registryBaseColorSchema.parse(result)\n  } catch (error) {\n    handleError(error)\n  }\n}\n\nexport async function resolveTree(\n  index: z.infer<typeof registryIndexSchema>,\n  names: string[]\n) {\n  const tree: z.infer<typeof registryIndexSchema> = []\n\n  for (const name of names) {\n    const entry = index.find((entry) => entry.name === name)\n\n    if (!entry) {\n      continue\n    }\n\n    tree.push(entry)\n\n    if (entry.registryDependencies) {\n      const dependencies = await resolveTree(index, entry.registryDependencies)\n      tree.push(...dependencies)\n    }\n  }\n\n  return tree.filter(\n    (component, index, self) =>\n      self.findIndex((c) => c.name === component.name) === index\n  )\n}\n\nexport async function fetchTree(\n  style: string,\n  tree: z.infer<typeof registryIndexSchema>\n) {\n  try {\n    const paths = tree.map((item) => `styles/${style}/${item.name}.json`)\n    const result = await fetchRegistry(paths)\n    return registryIndexSchema.parse(result)\n  } catch (error) {\n    handleError(error)\n  }\n}\n\nexport async function getItemTargetPath(\n  config: Config,\n  item: Pick<z.infer<typeof registryItemSchema>, \"type\">,\n  override?: string\n) {\n  if (override) {\n    return override\n  }\n\n  if (item.type === \"registry:ui\") {\n    return config.resolvedPaths.ui ?? config.resolvedPaths.components\n  }\n\n  const [parent, type] = item.type?.split(\":\") ?? []\n  if (!(parent in config.resolvedPaths)) {\n    return null\n  }\n\n  return path.join(\n    config.resolvedPaths[parent as keyof typeof config.resolvedPaths],\n    type\n  )\n}\n\nexport async function fetchRegistry(\n  paths: string[],\n  options: { useCache?: boolean } = {}\n) {\n  options = {\n    useCache: true,\n    ...options,\n  }\n\n  try {\n    const results = await Promise.all(\n      paths.map(async (path) => {\n        const url = getRegistryUrl(path)\n\n        // Check cache first if caching is enabled\n        if (options.useCache && registryCache.has(url)) {\n          return registryCache.get(url)\n        }\n\n        // Store the promise in the cache before awaiting if caching is enabled\n        const fetchPromise = (async () => {\n          const response = await fetch(url, { agent })\n\n          if (!response.ok) {\n            const errorMessages: { [key: number]: string } = {\n              400: \"Bad request\",\n              401: \"Unauthorized\",\n              403: \"Forbidden\",\n              404: \"Not found\",\n              500: \"Internal server error\",\n            }\n\n            if (response.status === 401) {\n              throw new Error(\n                `You are not authorized to access the component at ${highlighter.info(\n                  url\n                )}.\\nIf this is a remote registry, you may need to authenticate.`\n              )\n            }\n\n            if (response.status === 404) {\n              throw new Error(\n                `The component at ${highlighter.info(\n                  url\n                )} was not found.\\nIt may not exist at the registry. Please make sure it is a valid component.`\n              )\n            }\n\n            if (response.status === 403) {\n              throw new Error(\n                `You do not have access to the component at ${highlighter.info(\n                  url\n                )}.\\nIf this is a remote registry, you may need to authenticate or a token.`\n              )\n            }\n\n            const result = await response.json()\n            const message =\n              result && typeof result === \"object\" && \"error\" in result\n                ? result.error\n                : response.statusText || errorMessages[response.status]\n            throw new Error(\n              `Failed to fetch from ${highlighter.info(url)}.\\n${message}`\n            )\n          }\n\n          return response.json()\n        })()\n\n        if (options.useCache) {\n          registryCache.set(url, fetchPromise)\n        }\n        return fetchPromise\n      })\n    )\n\n    return results\n  } catch (error) {\n    logger.error(\"\\n\")\n    handleError(error)\n    return []\n  }\n}\n\nexport function clearRegistryCache() {\n  registryCache.clear()\n}\n\nasync function resolveDependenciesRecursively(\n  dependencies: string[],\n  config?: Config,\n  visited: Set<string> = new Set()\n): Promise<{\n  items: z.infer<typeof registryItemSchema>[]\n  registryNames: string[]\n}> {\n  const items: z.infer<typeof registryItemSchema>[] = []\n  const registryNames: string[] = []\n\n  for (const dep of dependencies) {\n    // Avoid infinite recursion.\n    if (visited.has(dep)) {\n      continue\n    }\n    visited.add(dep)\n\n    if (isUrl(dep) || isLocalFile(dep)) {\n      const item = await getRegistryItem(dep, \"\")\n      if (item) {\n        items.push(item)\n        if (item.registryDependencies) {\n          const nested = await resolveDependenciesRecursively(\n            item.registryDependencies,\n            config,\n            visited\n          )\n          items.push(...nested.items)\n          registryNames.push(...nested.registryNames)\n        }\n      }\n    } else {\n      // Registry name - add it to the list\n      registryNames.push(dep)\n\n      // If we have config, we can also fetch the item to get its dependencies\n      if (config) {\n        const style = config.resolvedPaths?.cwd\n          ? await getTargetStyleFromConfig(\n              config.resolvedPaths.cwd,\n              config.style\n            )\n          : config.style\n\n        try {\n          const item = await getRegistryItem(dep, style)\n          if (item && item.registryDependencies) {\n            const nested = await resolveDependenciesRecursively(\n              item.registryDependencies,\n              config,\n              visited\n            )\n            items.push(...nested.items)\n            registryNames.push(...nested.registryNames)\n          }\n        } catch (error) {\n          // If we can't fetch the registry item, that's okay - we'll still include the name\n        }\n      }\n    }\n  }\n\n  return { items, registryNames }\n}\n\nexport async function registryResolveItemsTree(\n  names: z.infer<typeof registryItemSchema>[\"name\"][],\n  config: Config\n) {\n  try {\n    // Separate local files, URLs, and registry names.\n    const localFiles = names.filter((name) => isLocalFile(name))\n    const urls = names.filter((name) => isUrl(name))\n    const registryNames = names.filter(\n      (name) => !isLocalFile(name) && !isUrl(name)\n    )\n\n    const payload: z.infer<typeof registryItemSchema>[] = []\n\n    // Handle local files and URLs directly, collecting their dependencies.\n    const allDependencies: string[] = []\n\n    for (const localFile of localFiles) {\n      const item = await getRegistryItem(localFile, \"\")\n      if (item) {\n        payload.push(item)\n        if (item.registryDependencies) {\n          allDependencies.push(...item.registryDependencies)\n        }\n      }\n    }\n\n    for (const url of urls) {\n      const item = await getRegistryItem(url, \"\")\n      if (item) {\n        payload.push(item)\n        if (item.registryDependencies) {\n          allDependencies.push(...item.registryDependencies)\n        }\n      }\n    }\n\n    // Recursively resolve all dependencies.\n    const { items: dependencyItems, registryNames: dependencyRegistryNames } =\n      await resolveDependenciesRecursively(allDependencies, config)\n\n    payload.push(...dependencyItems)\n\n    // Handle registry names using existing resolveRegistryItems logic.\n    const allRegistryNames = [...registryNames, ...dependencyRegistryNames]\n    if (allRegistryNames.length > 0) {\n      const index = await getRegistryIndex()\n      if (!index) {\n        // If we only have local files or URLs, that's fine.\n        if (payload.length === 0) {\n          return null\n        }\n      } else {\n        // Remove duplicates.\n        const uniqueRegistryNames = Array.from(new Set(allRegistryNames))\n\n        // If we're resolving the index, we want it to go first.\n        if (uniqueRegistryNames.includes(\"index\")) {\n          uniqueRegistryNames.unshift(\"index\")\n        }\n\n        let registryItems = await resolveRegistryItems(\n          uniqueRegistryNames,\n          config\n        )\n        let result = await fetchRegistry(registryItems)\n        const registryPayload = z.array(registryItemSchema).parse(result)\n        payload.push(...registryPayload)\n      }\n    }\n\n    if (!payload.length) {\n      return null\n    }\n\n    // If we're resolving the index, we want to fetch\n    // the theme item if a base color is provided.\n    // We do this for index only.\n    // Other components will ship with their theme tokens.\n    if (allRegistryNames.includes(\"index\")) {\n      if (config.tailwind.baseColor) {\n        const theme = await registryGetTheme(config.tailwind.baseColor, config)\n        if (theme) {\n          payload.unshift(theme)\n        }\n      }\n    }\n\n    // Sort the payload so that registry:theme is always first.\n    payload.sort((a, b) => {\n      if (a.type === \"registry:theme\") {\n        return -1\n      }\n      return 1\n    })\n\n    let tailwind = {}\n    payload.forEach((item) => {\n      tailwind = deepmerge(tailwind, item.tailwind ?? {})\n    })\n\n    let cssVars = {}\n    payload.forEach((item) => {\n      cssVars = deepmerge(cssVars, item.cssVars ?? {})\n    })\n\n    let css = {}\n    payload.forEach((item) => {\n      css = deepmerge(css, item.css ?? {})\n    })\n\n    let docs = \"\"\n    payload.forEach((item) => {\n      if (item.docs) {\n        docs += `${item.docs}\\n`\n      }\n    })\n\n    return registryResolvedItemsTreeSchema.parse({\n      dependencies: deepmerge.all(\n        payload.map((item) => item.dependencies ?? [])\n      ),\n      devDependencies: deepmerge.all(\n        payload.map((item) => item.devDependencies ?? [])\n      ),\n      files: deepmerge.all(payload.map((item) => item.files ?? [])),\n      tailwind,\n      cssVars,\n      css,\n      docs,\n    })\n  } catch (error) {\n    handleError(error)\n    return null\n  }\n}\n\nasync function resolveRegistryDependencies(\n  url: string,\n  config: Config\n): Promise<string[]> {\n  const { registryNames } = await resolveDependenciesRecursively([url], config)\n\n  const style = config.resolvedPaths?.cwd\n    ? await getTargetStyleFromConfig(config.resolvedPaths.cwd, config.style)\n    : config.style\n\n  const urls = registryNames.map((name) =>\n    getRegistryUrl(isUrl(name) ? name : `styles/${style}/${name}.json`)\n  )\n\n  return Array.from(new Set(urls))\n}\n\nexport async function registryGetTheme(name: string, config: Config) {\n  const [baseColor, tailwindVersion] = await Promise.all([\n    getRegistryBaseColor(name),\n    getProjectTailwindVersionFromConfig(config),\n  ])\n  if (!baseColor) {\n    return null\n  }\n\n  // TODO: Move this to the registry i.e registry:theme.\n  const theme = {\n    name,\n    type: \"registry:theme\",\n    tailwind: {\n      config: {\n        theme: {\n          extend: {\n            borderRadius: {\n              lg: \"var(--radius)\",\n              md: \"calc(var(--radius) - 2px)\",\n              sm: \"calc(var(--radius) - 4px)\",\n            },\n            colors: {},\n          },\n        },\n      },\n    },\n    cssVars: {\n      theme: {},\n      light: {\n        radius: \"0.5rem\",\n      },\n      dark: {},\n    },\n  } satisfies z.infer<typeof registryItemSchema>\n\n  if (config.tailwind.cssVariables) {\n    theme.tailwind.config.theme.extend.colors = {\n      ...theme.tailwind.config.theme.extend.colors,\n      ...buildTailwindThemeColorsFromCssVars(baseColor.cssVars.dark ?? {}),\n    }\n    theme.cssVars = {\n      theme: {\n        ...baseColor.cssVars.theme,\n        ...theme.cssVars.theme,\n      },\n      light: {\n        ...baseColor.cssVars.light,\n        ...theme.cssVars.light,\n      },\n      dark: {\n        ...baseColor.cssVars.dark,\n        ...theme.cssVars.dark,\n      },\n    }\n\n    if (tailwindVersion === \"v4\" && baseColor.cssVarsV4) {\n      theme.cssVars = {\n        theme: {\n          ...baseColor.cssVarsV4.theme,\n          ...theme.cssVars.theme,\n        },\n        light: {\n          radius: \"0.625rem\",\n          ...baseColor.cssVarsV4.light,\n        },\n        dark: {\n          ...baseColor.cssVarsV4.dark,\n        },\n      }\n    }\n  }\n\n  return theme\n}\n\nfunction getRegistryUrl(path: string) {\n  if (isUrl(path)) {\n    // If the url contains /chat/b/, we assume it's the v0 registry.\n    // We need to add the /json suffix if it's missing.\n    const url = new URL(path)\n    if (url.pathname.match(/\\/chat\\/b\\//) && !url.pathname.endsWith(\"/json\")) {\n      url.pathname = `${url.pathname}/json`\n    }\n\n    return url.toString()\n  }\n\n  return `${REGISTRY_URL}/${path}`\n}\n\nexport function isUrl(path: string) {\n  try {\n    new URL(path)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\n// TODO: We're double-fetching here. Use a cache.\nexport async function resolveRegistryItems(names: string[], config: Config) {\n  let registryDependencies: string[] = []\n\n  // Filter out local files and URLs - these should be handled directly by getRegistryItem\n  const registryNames = names.filter(\n    (name) => !isLocalFile(name) && !isUrl(name)\n  )\n\n  for (const name of registryNames) {\n    const itemRegistryDependencies = await resolveRegistryDependencies(\n      name,\n      config\n    )\n    registryDependencies.push(...itemRegistryDependencies)\n  }\n\n  return Array.from(new Set(registryDependencies))\n}\n\nexport function getRegistryTypeAliasMap() {\n  return new Map<string, string>([\n    [\"registry:ui\", \"ui\"],\n    [\"registry:lib\", \"lib\"],\n    [\"registry:hook\", \"hooks\"],\n    [\"registry:block\", \"components\"],\n    [\"registry:component\", \"components\"],\n  ])\n}\n\n// Track a dependency and its parent.\nexport function getRegistryParentMap(\n  registryItems: z.infer<typeof registryItemSchema>[]\n) {\n  const map = new Map<string, z.infer<typeof registryItemSchema>>()\n  registryItems.forEach((item) => {\n    if (!item.registryDependencies) {\n      return\n    }\n\n    item.registryDependencies.forEach((dependency) => {\n      map.set(dependency, item)\n    })\n  })\n  return map\n}\n","import * as fs from \"fs/promises\"\nimport { tmpdir } from \"os\"\nimport * as path from \"path\"\nimport { registryItemSchema } from \"@/src/registry\"\nimport { configSchema } from \"@/src/utils/get-config\"\nimport { ProjectInfo } from \"@/src/utils/get-project-info\"\nimport { resolveImport } from \"@/src/utils/resolve-import\"\nimport { Project, ScriptKind } from \"ts-morph\"\nimport { loadConfig } from \"tsconfig-paths\"\nimport { z } from \"zod\"\n\nconst FILE_EXTENSIONS_FOR_LOOKUP = [\".tsx\", \".ts\", \".jsx\", \".js\", \".css\"]\nconst FILE_PATH_SKIP_LIST = [\"lib/utils.ts\"]\nconst DEPENDENCY_SKIP_LIST = [\n  /^(react|react-dom|next)(\\/.*)?$/, // Matches react, react-dom, next and their submodules\n  /^(node|jsr|npm):.*$/, // Matches node:, jsr:, and npm: prefixed modules\n]\n\nconst project = new Project({\n  compilerOptions: {},\n})\n\n// This returns the dependency from the module specifier.\n// Here dependency means an npm package.\nexport function getDependencyFromModuleSpecifier(\n  moduleSpecifier: string\n): string | null {\n  // Skip if the dependency matches any pattern in the skip list\n  if (DEPENDENCY_SKIP_LIST.some((pattern) => pattern.test(moduleSpecifier))) {\n    return null\n  }\n\n  // If the module specifier does not start with `@` and has a /, add the dependency first part only.\n  // E.g. `foo/bar` -> `foo`\n  if (!moduleSpecifier.startsWith(\"@\") && moduleSpecifier.includes(\"/\")) {\n    moduleSpecifier = moduleSpecifier.split(\"/\")[0]\n  }\n\n  // For scoped packages, we want to keep the first two parts\n  // E.g. `@types/react/dom` -> `@types/react`\n  if (moduleSpecifier.startsWith(\"@\")) {\n    const parts = moduleSpecifier.split(\"/\")\n    if (parts.length > 2) {\n      moduleSpecifier = parts.slice(0, 2).join(\"/\")\n    }\n  }\n\n  return moduleSpecifier\n}\n\nexport async function recursivelyResolveFileImports(\n  filePath: string,\n  config: z.infer<typeof configSchema>,\n  projectInfo: ProjectInfo,\n  processedFiles: Set<string> = new Set()\n): Promise<Pick<z.infer<typeof registryItemSchema>, \"files\" | \"dependencies\">> {\n  const resolvedFilePath = path.resolve(config.resolvedPaths.cwd, filePath)\n  const relativeRegistryFilePath = path.relative(\n    config.resolvedPaths.cwd,\n    resolvedFilePath\n  )\n\n  // Skip if the file is in the skip list\n  if (FILE_PATH_SKIP_LIST.includes(relativeRegistryFilePath)) {\n    return { dependencies: [], files: [] }\n  }\n\n  // Skip if the file extension is not one of the supported extensions\n  const fileExtension = path.extname(filePath)\n  if (!FILE_EXTENSIONS_FOR_LOOKUP.includes(fileExtension)) {\n    return { dependencies: [], files: [] }\n  }\n\n  // Prevent infinite loop: skip if already processed\n  if (processedFiles.has(relativeRegistryFilePath)) {\n    return { dependencies: [], files: [] }\n  }\n  processedFiles.add(relativeRegistryFilePath)\n\n  const stat = await fs.stat(resolvedFilePath)\n  if (!stat.isFile()) {\n    // Optionally log or handle this case\n    return { dependencies: [], files: [] }\n  }\n\n  const content = await fs.readFile(resolvedFilePath, \"utf-8\")\n  const tempFile = await createTempSourceFile(path.basename(resolvedFilePath))\n  const sourceFile = project.createSourceFile(tempFile, content, {\n    scriptKind: ScriptKind.TSX,\n  })\n  const tsConfig = await loadConfig(config.resolvedPaths.cwd)\n  if (tsConfig.resultType === \"failed\") {\n    return { dependencies: [], files: [] }\n  }\n\n  const files: z.infer<typeof registryItemSchema>[\"files\"] = []\n  const dependencies = new Set<string>()\n\n  // Add the original file first\n  const fileType = determineFileType(filePath)\n  const originalFile = {\n    path: relativeRegistryFilePath,\n    type: fileType,\n    target: \"\",\n  }\n  files.push(originalFile)\n\n  // 1. Find all import statements in the file.\n  const importStatements = sourceFile.getImportDeclarations()\n  for (const importStatement of importStatements) {\n    const moduleSpecifier = importStatement.getModuleSpecifierValue()\n\n    const isRelativeImport = moduleSpecifier.startsWith(\".\")\n    const isAliasImport = moduleSpecifier.startsWith(\n      `${projectInfo.aliasPrefix}/`\n    )\n\n    // If not a local import, add to the dependencies array.\n    if (!isAliasImport && !isRelativeImport) {\n      const dependency = getDependencyFromModuleSpecifier(moduleSpecifier)\n      if (dependency) {\n        dependencies.add(dependency)\n      }\n      continue\n    }\n\n    let probableImportFilePath = await resolveImport(moduleSpecifier, tsConfig)\n\n    if (isRelativeImport) {\n      probableImportFilePath = path.resolve(\n        path.dirname(resolvedFilePath),\n        moduleSpecifier\n      )\n    }\n\n    if (!probableImportFilePath) {\n      continue\n    }\n\n    // Check if the probable import path has a file extension.\n    // Try each extension until we find a file that exists.\n    const hasExtension = path.extname(probableImportFilePath)\n    if (!hasExtension) {\n      for (const ext of FILE_EXTENSIONS_FOR_LOOKUP) {\n        const pathWithExt: string = `${probableImportFilePath}${ext}`\n        try {\n          await fs.access(pathWithExt)\n          probableImportFilePath = pathWithExt\n          break\n        } catch {\n          continue\n        }\n      }\n    }\n\n    const nestedRelativeRegistryFilePath = path.relative(\n      config.resolvedPaths.cwd,\n      probableImportFilePath\n    )\n\n    // Skip if we've already processed this file or if it's in the skip list\n    if (\n      processedFiles.has(nestedRelativeRegistryFilePath) ||\n      FILE_PATH_SKIP_LIST.includes(nestedRelativeRegistryFilePath)\n    ) {\n      continue\n    }\n\n    const fileType = determineFileType(moduleSpecifier)\n    const file = {\n      path: nestedRelativeRegistryFilePath,\n      type: fileType,\n      target: \"\",\n    }\n\n    // TODO (shadcn): fix this.\n    if (fileType === \"registry:page\" || fileType === \"registry:file\") {\n      file.target = moduleSpecifier\n    }\n\n    files.push(file)\n\n    // Recursively process the imported file, passing the shared processedFiles set\n    const nestedResults = await recursivelyResolveFileImports(\n      nestedRelativeRegistryFilePath,\n      config,\n      projectInfo,\n      processedFiles\n    )\n\n    if (nestedResults.files) {\n      // Only add files that haven't been processed yet\n      for (const file of nestedResults.files) {\n        if (!processedFiles.has(file.path)) {\n          processedFiles.add(file.path)\n          files.push(file)\n        }\n      }\n    }\n\n    if (nestedResults.dependencies) {\n      nestedResults.dependencies.forEach((dep) => dependencies.add(dep))\n    }\n  }\n\n  // Deduplicate files by path\n  const uniqueFiles = Array.from(\n    new Map(files.map((file) => [file.path, file])).values()\n  )\n\n  return {\n    dependencies: Array.from(dependencies),\n    files: uniqueFiles,\n  }\n}\n\nasync function createTempSourceFile(filename: string) {\n  const dir = await fs.mkdtemp(path.join(tmpdir(), \"shadcn-\"))\n  return path.join(dir, filename)\n}\n\n// This is a bit tricky to accurately determine.\n// For now we'll use the module specifier to determine the type.\nfunction determineFileType(\n  moduleSpecifier: string\n): z.infer<typeof registryItemSchema>[\"type\"] {\n  if (moduleSpecifier.includes(\"/ui/\")) {\n    return \"registry:ui\"\n  }\n\n  if (moduleSpecifier.includes(\"/lib/\")) {\n    return \"registry:lib\"\n  }\n\n  if (moduleSpecifier.includes(\"/hooks/\")) {\n    return \"registry:hook\"\n  }\n\n  if (moduleSpecifier.includes(\"/components/\")) {\n    return \"registry:component\"\n  }\n\n  return \"registry:component\"\n}\n\n// Additional utility functions for local file support\nexport function isUrl(path: string) {\n  try {\n    new URL(path)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nexport function isLocalFile(path: string) {\n  return path.endsWith(\".json\") && !isUrl(path)\n}\n","import { createMatchPath, type ConfigLoaderSuccessResult } from \"tsconfig-paths\"\n\nexport async function resolveImport(\n  importPath: string,\n  config: Pick<ConfigLoaderSuccessResult, \"absoluteBaseUrl\" | \"paths\">\n) {\n  return createMatchPath(config.absoluteBaseUrl, config.paths)(\n    importPath,\n    undefined,\n    () => true,\n    [\".ts\", \".tsx\", \".jsx\", \".js\", \".css\"]\n  )\n}\n","import path from \"path\"\nimport { getProjectInfo } from \"@/src/utils/get-project-info\"\nimport { highlighter } from \"@/src/utils/highlighter\"\nimport { resolveImport } from \"@/src/utils/resolve-import\"\nimport { cosmiconfig } from \"cosmiconfig\"\nimport fg from \"fast-glob\"\nimport { loadConfig } from \"tsconfig-paths\"\nimport { z } from \"zod\"\n\nexport const DEFAULT_STYLE = \"default\"\nexport const DEFAULT_COMPONENTS = \"@/components\"\nexport const DEFAULT_UTILS = \"@/lib/utils\"\nexport const DEFAULT_TAILWIND_CSS = \"app/globals.css\"\nexport const DEFAULT_TAILWIND_CONFIG = \"tailwind.config.js\"\nexport const DEFAULT_TAILWIND_BASE_COLOR = \"slate\"\n\n// TODO: Figure out if we want to support all cosmiconfig formats.\n// A simple components.json file would be nice.\nconst explorer = cosmiconfig(\"components\", {\n  searchPlaces: [\"components.json\"],\n})\n\nexport const rawConfigSchema = z\n  .object({\n    $schema: z.string().optional(),\n    style: z.string(),\n    rsc: z.coerce.boolean().default(false),\n    tsx: z.coerce.boolean().default(true),\n    tailwind: z.object({\n      config: z.string().optional(),\n      css: z.string(),\n      baseColor: z.string(),\n      cssVariables: z.boolean().default(true),\n      prefix: z.string().default(\"\").optional(),\n    }),\n    aliases: z.object({\n      components: z.string(),\n      utils: z.string(),\n      ui: z.string().optional(),\n      lib: z.string().optional(),\n      hooks: z.string().optional(),\n    }),\n    iconLibrary: z.string().optional(),\n  })\n  .strict()\n\nexport type RawConfig = z.infer<typeof rawConfigSchema>\n\nexport const configSchema = rawConfigSchema.extend({\n  resolvedPaths: z.object({\n    cwd: z.string(),\n    tailwindConfig: z.string(),\n    tailwindCss: z.string(),\n    utils: z.string(),\n    components: z.string(),\n    lib: z.string(),\n    hooks: z.string(),\n    ui: z.string(),\n  }),\n})\n\nexport type Config = z.infer<typeof configSchema>\n\n// TODO: type the key.\n// Okay for now since I don't want a breaking change.\nexport const workspaceConfigSchema = z.record(configSchema)\n\nexport async function getConfig(cwd: string) {\n  const config = await getRawConfig(cwd)\n\n  if (!config) {\n    return null\n  }\n\n  // Set default icon library if not provided.\n  if (!config.iconLibrary) {\n    config.iconLibrary = config.style === \"new-york\" ? \"radix\" : \"lucide\"\n  }\n\n  return await resolveConfigPaths(cwd, config)\n}\n\nexport async function resolveConfigPaths(cwd: string, config: RawConfig) {\n  // Read tsconfig.json.\n  const tsConfig = await loadConfig(cwd)\n\n  if (tsConfig.resultType === \"failed\") {\n    throw new Error(\n      `Failed to load ${config.tsx ? \"tsconfig\" : \"jsconfig\"}.json. ${\n        tsConfig.message ?? \"\"\n      }`.trim()\n    )\n  }\n\n  return configSchema.parse({\n    ...config,\n    resolvedPaths: {\n      cwd,\n      tailwindConfig: config.tailwind.config\n        ? path.resolve(cwd, config.tailwind.config)\n        : \"\",\n      tailwindCss: path.resolve(cwd, config.tailwind.css),\n      utils: await resolveImport(config.aliases[\"utils\"], tsConfig),\n      components: await resolveImport(config.aliases[\"components\"], tsConfig),\n      ui: config.aliases[\"ui\"]\n        ? await resolveImport(config.aliases[\"ui\"], tsConfig)\n        : path.resolve(\n            (await resolveImport(config.aliases[\"components\"], tsConfig)) ??\n              cwd,\n            \"ui\"\n          ),\n      // TODO: Make this configurable.\n      // For now, we assume the lib and hooks directories are one level up from the components directory.\n      lib: config.aliases[\"lib\"]\n        ? await resolveImport(config.aliases[\"lib\"], tsConfig)\n        : path.resolve(\n            (await resolveImport(config.aliases[\"utils\"], tsConfig)) ?? cwd,\n            \"..\"\n          ),\n      hooks: config.aliases[\"hooks\"]\n        ? await resolveImport(config.aliases[\"hooks\"], tsConfig)\n        : path.resolve(\n            (await resolveImport(config.aliases[\"components\"], tsConfig)) ??\n              cwd,\n            \"..\",\n            \"hooks\"\n          ),\n    },\n  })\n}\n\nexport async function getRawConfig(cwd: string): Promise<RawConfig | null> {\n  try {\n    const configResult = await explorer.search(cwd)\n\n    if (!configResult) {\n      return null\n    }\n\n    return rawConfigSchema.parse(configResult.config)\n  } catch (error) {\n    const componentPath = `${cwd}/components.json`\n    throw new Error(\n      `Invalid configuration found in ${highlighter.info(componentPath)}.`\n    )\n  }\n}\n\n// Note: we can check for -workspace.yaml or \"workspace\" in package.json.\n// Since cwd is not necessarily the root of the project.\n// We'll instead check if ui aliases resolve to a different root.\nexport async function getWorkspaceConfig(config: Config) {\n  let resolvedAliases: any = {}\n\n  for (const key of Object.keys(config.aliases)) {\n    if (!isAliasKey(key, config)) {\n      continue\n    }\n\n    const resolvedPath = config.resolvedPaths[key]\n    const packageRoot = await findPackageRoot(\n      config.resolvedPaths.cwd,\n      resolvedPath\n    )\n\n    if (!packageRoot) {\n      resolvedAliases[key] = config\n      continue\n    }\n\n    resolvedAliases[key] = await getConfig(packageRoot)\n  }\n\n  const result = workspaceConfigSchema.safeParse(resolvedAliases)\n  if (!result.success) {\n    return null\n  }\n\n  return result.data\n}\n\nexport async function findPackageRoot(cwd: string, resolvedPath: string) {\n  const commonRoot = findCommonRoot(cwd, resolvedPath)\n  const relativePath = path.relative(commonRoot, resolvedPath)\n\n  const packageRoots = await fg.glob(\"**/package.json\", {\n    cwd: commonRoot,\n    deep: 3,\n    ignore: [\"**/node_modules/**\", \"**/dist/**\", \"**/build/**\", \"**/public/**\"],\n  })\n\n  const matchingPackageRoot = packageRoots\n    .map((pkgPath) => path.dirname(pkgPath))\n    .find((pkgDir) => relativePath.startsWith(pkgDir))\n\n  return matchingPackageRoot ? path.join(commonRoot, matchingPackageRoot) : null\n}\n\nfunction isAliasKey(\n  key: string,\n  config: Config\n): key is keyof Config[\"aliases\"] {\n  return Object.keys(config.resolvedPaths)\n    .filter((key) => key !== \"utils\")\n    .includes(key)\n}\n\nexport function findCommonRoot(cwd: string, resolvedPath: string) {\n  const parts1 = cwd.split(path.sep)\n  const parts2 = resolvedPath.split(path.sep)\n  const commonParts = []\n\n  for (let i = 0; i < Math.min(parts1.length, parts2.length); i++) {\n    if (parts1[i] !== parts2[i]) {\n      break\n    }\n    commonParts.push(parts1[i])\n  }\n\n  return commonParts.join(path.sep)\n}\n\n// TODO: Cache this call.\nexport async function getTargetStyleFromConfig(cwd: string, fallback: string) {\n  const projectInfo = await getProjectInfo(cwd)\n  return projectInfo?.tailwindVersion === \"v4\" ? \"new-york-v4\" : fallback\n}\n","import path from \"path\"\nimport { FRAMEWORKS, Framework } from \"@/src/utils/frameworks\"\nimport {\n  Config,\n  RawConfig,\n  getConfig,\n  resolveConfigPaths,\n} from \"@/src/utils/get-config\"\nimport { getPackageInfo } from \"@/src/utils/get-package-info\"\nimport fg from \"fast-glob\"\nimport fs from \"fs-extra\"\nimport { loadConfig } from \"tsconfig-paths\"\nimport { z } from \"zod\"\n\nexport type TailwindVersion = \"v3\" | \"v4\" | null\n\nexport type ProjectInfo = {\n  framework: Framework\n  isSrcDir: boolean\n  isRSC: boolean\n  isTsx: boolean\n  tailwindConfigFile: string | null\n  tailwindCssFile: string | null\n  tailwindVersion: TailwindVersion\n  aliasPrefix: string | null\n}\n\nconst PROJECT_SHARED_IGNORE = [\n  \"**/node_modules/**\",\n  \".next\",\n  \"public\",\n  \"dist\",\n  \"build\",\n]\n\nconst TS_CONFIG_SCHEMA = z.object({\n  compilerOptions: z.object({\n    paths: z.record(z.string().or(z.array(z.string()))),\n  }),\n})\n\nexport async function getProjectInfo(cwd: string): Promise<ProjectInfo | null> {\n  const [\n    configFiles,\n    isSrcDir,\n    isTsx,\n    tailwindConfigFile,\n    tailwindCssFile,\n    tailwindVersion,\n    aliasPrefix,\n    packageJson,\n  ] = await Promise.all([\n    fg.glob(\n      \"**/{next,vite,astro,app}.config.*|gatsby-config.*|composer.json|react-router.config.*\",\n      {\n        cwd,\n        deep: 3,\n        ignore: PROJECT_SHARED_IGNORE,\n      }\n    ),\n    fs.pathExists(path.resolve(cwd, \"src\")),\n    isTypeScriptProject(cwd),\n    getTailwindConfigFile(cwd),\n    getTailwindCssFile(cwd),\n    getTailwindVersion(cwd),\n    getTsConfigAliasPrefix(cwd),\n    getPackageInfo(cwd, false),\n  ])\n\n  const isUsingAppDir = await fs.pathExists(\n    path.resolve(cwd, `${isSrcDir ? \"src/\" : \"\"}app`)\n  )\n\n  const type: ProjectInfo = {\n    framework: FRAMEWORKS[\"manual\"],\n    isSrcDir,\n    isRSC: false,\n    isTsx,\n    tailwindConfigFile,\n    tailwindCssFile,\n    tailwindVersion,\n    aliasPrefix,\n  }\n\n  // Next.js.\n  if (configFiles.find((file) => file.startsWith(\"next.config.\"))?.length) {\n    type.framework = isUsingAppDir\n      ? FRAMEWORKS[\"next-app\"]\n      : FRAMEWORKS[\"next-pages\"]\n    type.isRSC = isUsingAppDir\n    return type\n  }\n\n  // Astro.\n  if (configFiles.find((file) => file.startsWith(\"astro.config.\"))?.length) {\n    type.framework = FRAMEWORKS[\"astro\"]\n    return type\n  }\n\n  // Gatsby.\n  if (configFiles.find((file) => file.startsWith(\"gatsby-config.\"))?.length) {\n    type.framework = FRAMEWORKS[\"gatsby\"]\n    return type\n  }\n\n  // Laravel.\n  if (configFiles.find((file) => file.startsWith(\"composer.json\"))?.length) {\n    type.framework = FRAMEWORKS[\"laravel\"]\n    return type\n  }\n\n  // Remix.\n  if (\n    Object.keys(packageJson?.dependencies ?? {}).find((dep) =>\n      dep.startsWith(\"@remix-run/\")\n    )\n  ) {\n    type.framework = FRAMEWORKS[\"remix\"]\n    return type\n  }\n\n  // TanStack Start.\n  if (\n    [\n      ...Object.keys(packageJson?.dependencies ?? {}),\n      ...Object.keys(packageJson?.devDependencies ?? {}),\n    ].find((dep) => dep.startsWith(\"@tanstack/react-start\"))\n  ) {\n    type.framework = FRAMEWORKS[\"tanstack-start\"]\n    return type\n  }\n\n  // React Router.\n  if (\n    configFiles.find((file) => file.startsWith(\"react-router.config.\"))?.length\n  ) {\n    type.framework = FRAMEWORKS[\"react-router\"]\n    return type\n  }\n\n  // Vite.\n  // Some Remix templates also have a vite.config.* file.\n  // We'll assume that it got caught by the Remix check above.\n  if (configFiles.find((file) => file.startsWith(\"vite.config.\"))?.length) {\n    type.framework = FRAMEWORKS[\"vite\"]\n    return type\n  }\n\n  // Vinxi-based (such as @tanstack/start and @solidjs/solid-start)\n  // They are vite-based, and the same configurations used for Vite should work flawlessly\n  const appConfig = configFiles.find((file) => file.startsWith(\"app.config\"))\n  if (appConfig?.length) {\n    const appConfigContents = await fs.readFile(\n      path.resolve(cwd, appConfig),\n      \"utf8\"\n    )\n    if (appConfigContents.includes(\"defineConfig\")) {\n      type.framework = FRAMEWORKS[\"vite\"]\n      return type\n    }\n  }\n\n  // Expo.\n  if (packageJson?.dependencies?.expo) {\n    type.framework = FRAMEWORKS[\"expo\"]\n    return type\n  }\n\n  return type\n}\n\nexport async function getTailwindVersion(\n  cwd: string\n): Promise<ProjectInfo[\"tailwindVersion\"]> {\n  const [packageInfo, config] = await Promise.all([\n    getPackageInfo(cwd, false),\n    getConfig(cwd),\n  ])\n\n  // If the config file is empty, we can assume that it's a v4 project.\n  if (config?.tailwind?.config === \"\") {\n    return \"v4\"\n  }\n\n  if (\n    !packageInfo?.dependencies?.tailwindcss &&\n    !packageInfo?.devDependencies?.tailwindcss\n  ) {\n    return null\n  }\n\n  if (\n    /^(?:\\^|~)?3(?:\\.\\d+)*(?:-.*)?$/.test(\n      packageInfo?.dependencies?.tailwindcss ||\n        packageInfo?.devDependencies?.tailwindcss ||\n        \"\"\n    )\n  ) {\n    return \"v3\"\n  }\n\n  return \"v4\"\n}\n\nexport async function getTailwindCssFile(cwd: string) {\n  const [files, tailwindVersion] = await Promise.all([\n    fg.glob([\"**/*.css\", \"**/*.scss\"], {\n      cwd,\n      deep: 5,\n      ignore: PROJECT_SHARED_IGNORE,\n    }),\n    getTailwindVersion(cwd),\n  ])\n\n  if (!files.length) {\n    return null\n  }\n\n  const needle =\n    tailwindVersion === \"v4\" ? `@import \"tailwindcss\"` : \"@tailwind base\"\n  for (const file of files) {\n    const contents = await fs.readFile(path.resolve(cwd, file), \"utf8\")\n    if (\n      contents.includes(`@import \"tailwindcss\"`) ||\n      contents.includes(`@import 'tailwindcss'`) ||\n      contents.includes(`@tailwind base`)\n    ) {\n      return file\n    }\n  }\n\n  return null\n}\n\nexport async function getTailwindConfigFile(cwd: string) {\n  const files = await fg.glob(\"tailwind.config.*\", {\n    cwd,\n    deep: 3,\n    ignore: PROJECT_SHARED_IGNORE,\n  })\n\n  if (!files.length) {\n    return null\n  }\n\n  return files[0]\n}\n\nexport async function getTsConfigAliasPrefix(cwd: string) {\n  const tsConfig = await loadConfig(cwd)\n\n  if (\n    tsConfig?.resultType === \"failed\" ||\n    !Object.entries(tsConfig?.paths).length\n  ) {\n    return null\n  }\n\n  // This assume that the first alias is the prefix.\n  for (const [alias, paths] of Object.entries(tsConfig.paths)) {\n    if (\n      paths.includes(\"./*\") ||\n      paths.includes(\"./src/*\") ||\n      paths.includes(\"./app/*\") ||\n      paths.includes(\"./resources/js/*\") // Laravel.\n    ) {\n      return alias.replace(/\\/\\*$/, \"\") ?? null\n    }\n  }\n\n  // Use the first alias as the prefix.\n  return Object.keys(tsConfig?.paths)?.[0].replace(/\\/\\*$/, \"\") ?? null\n}\n\nexport async function isTypeScriptProject(cwd: string) {\n  const files = await fg.glob(\"tsconfig.*\", {\n    cwd,\n    deep: 1,\n    ignore: PROJECT_SHARED_IGNORE,\n  })\n\n  return files.length > 0\n}\n\nexport async function getTsConfig(cwd: string) {\n  for (const fallback of [\n    \"tsconfig.json\",\n    \"tsconfig.web.json\",\n    \"tsconfig.app.json\",\n  ]) {\n    const filePath = path.resolve(cwd, fallback)\n    if (!(await fs.pathExists(filePath))) {\n      continue\n    }\n\n    // We can't use fs.readJSON because it doesn't support comments.\n    const contents = await fs.readFile(filePath, \"utf8\")\n    const cleanedContents = contents.replace(/\\/\\*\\s*\\*\\//g, \"\")\n    const result = TS_CONFIG_SCHEMA.safeParse(JSON.parse(cleanedContents))\n\n    if (result.error) {\n      continue\n    }\n\n    return result.data\n  }\n\n  return null\n}\n\nexport async function getProjectConfig(\n  cwd: string,\n  defaultProjectInfo: ProjectInfo | null = null\n): Promise<Config | null> {\n  // Check for existing component config.\n  const [existingConfig, projectInfo] = await Promise.all([\n    getConfig(cwd),\n    !defaultProjectInfo\n      ? getProjectInfo(cwd)\n      : Promise.resolve(defaultProjectInfo),\n  ])\n\n  if (existingConfig) {\n    return existingConfig\n  }\n\n  if (\n    !projectInfo ||\n    !projectInfo.tailwindCssFile ||\n    (projectInfo.tailwindVersion === \"v3\" && !projectInfo.tailwindConfigFile)\n  ) {\n    return null\n  }\n\n  const config: RawConfig = {\n    $schema: \"https://ui.shadcn.com/schema.json\",\n    rsc: projectInfo.isRSC,\n    tsx: projectInfo.isTsx,\n    style: \"new-york\",\n    tailwind: {\n      config: projectInfo.tailwindConfigFile ?? \"\",\n      baseColor: \"zinc\",\n      css: projectInfo.tailwindCssFile,\n      cssVariables: true,\n      prefix: \"\",\n    },\n    iconLibrary: \"lucide\",\n    aliases: {\n      components: `${projectInfo.aliasPrefix}/components`,\n      ui: `${projectInfo.aliasPrefix}/components/ui`,\n      hooks: `${projectInfo.aliasPrefix}/hooks`,\n      lib: `${projectInfo.aliasPrefix}/lib`,\n      utils: `${projectInfo.aliasPrefix}/lib/utils`,\n    },\n  }\n\n  return await resolveConfigPaths(cwd, config)\n}\n\nexport async function getProjectTailwindVersionFromConfig(\n  config: Config\n): Promise<TailwindVersion> {\n  if (!config.resolvedPaths?.cwd) {\n    return \"v3\"\n  }\n\n  const projectInfo = await getProjectInfo(config.resolvedPaths.cwd)\n\n  if (!projectInfo?.tailwindVersion) {\n    return null\n  }\n\n  return projectInfo.tailwindVersion\n}\n","export const FRAMEWORKS = {\n  \"next-app\": {\n    name: \"next-app\",\n    label: \"Next.js\",\n    links: {\n      installation: \"https://ui.shadcn.com/docs/installation/next\",\n      tailwind: \"https://tailwindcss.com/docs/guides/nextjs\",\n    },\n  },\n  \"next-pages\": {\n    name: \"next-pages\",\n    label: \"Next.js\",\n    links: {\n      installation: \"https://ui.shadcn.com/docs/installation/next\",\n      tailwind: \"https://tailwindcss.com/docs/guides/nextjs\",\n    },\n  },\n  remix: {\n    name: \"remix\",\n    label: \"Remix\",\n    links: {\n      installation: \"https://ui.shadcn.com/docs/installation/remix\",\n      tailwind: \"https://tailwindcss.com/docs/guides/remix\",\n    },\n  },\n  \"react-router\": {\n    name: \"react-router\",\n    label: \"React Router\",\n    links: {\n      installation: \"https://ui.shadcn.com/docs/installation/react-router\",\n      tailwind:\n        \"https://tailwindcss.com/docs/installation/framework-guides/react-router\",\n    },\n  },\n  vite: {\n    name: \"vite\",\n    label: \"Vite\",\n    links: {\n      installation: \"https://ui.shadcn.com/docs/installation/vite\",\n      tailwind: \"https://tailwindcss.com/docs/guides/vite\",\n    },\n  },\n  astro: {\n    name: \"astro\",\n    label: \"Astro\",\n    links: {\n      installation: \"https://ui.shadcn.com/docs/installation/astro\",\n      tailwind: \"https://tailwindcss.com/docs/guides/astro\",\n    },\n  },\n  laravel: {\n    name: \"laravel\",\n    label: \"Laravel\",\n    links: {\n      installation: \"https://ui.shadcn.com/docs/installation/laravel\",\n      tailwind: \"https://tailwindcss.com/docs/guides/laravel\",\n    },\n  },\n  \"tanstack-start\": {\n    name: \"tanstack-start\",\n    label: \"TanStack Start\",\n    links: {\n      installation: \"https://ui.shadcn.com/docs/installation/tanstack\",\n      tailwind: \"https://tailwindcss.com/docs/installation/using-postcss\",\n    },\n  },\n  gatsby: {\n    name: \"gatsby\",\n    label: \"Gatsby\",\n    links: {\n      installation: \"https://ui.shadcn.com/docs/installation/gatsby\",\n      tailwind: \"https://tailwindcss.com/docs/guides/gatsby\",\n    },\n  },\n  expo: {\n    name: \"expo\",\n    label: \"Expo\",\n    links: {\n      installation: \"https://ui.shadcn.com/docs/installation/expo\",\n      tailwind: \"https://www.nativewind.dev/docs/getting-started/installation\",\n    },\n  },\n  manual: {\n    name: \"manual\",\n    label: \"Manual\",\n    links: {\n      installation: \"https://ui.shadcn.com/docs/installation/manual\",\n      tailwind: \"https://tailwindcss.com/docs/installation\",\n    },\n  },\n} as const\n\nexport type Framework = (typeof FRAMEWORKS)[keyof typeof FRAMEWORKS]\n","import path from \"path\"\nimport fs from \"fs-extra\"\nimport { type PackageJson } from \"type-fest\"\n\nexport function getPackageInfo(\n  cwd: string = \"\",\n  shouldThrow: boolean = true\n): PackageJson | null {\n  const packageJsonPath = path.join(cwd, \"package.json\")\n\n  return fs.readJSONSync(packageJsonPath, {\n    throws: shouldThrow,\n  }) as PackageJson\n}\n","import { cyan, green, red, yellow } from \"kleur/colors\"\n\nexport const highlighter = {\n  error: red,\n  warn: yellow,\n  info: cyan,\n  success: green,\n}\n","import { highlighter } from \"@/src/utils/highlighter\"\n\nexport const logger = {\n  error(...args: unknown[]) {\n    console.log(highlighter.error(args.join(\" \")))\n  },\n  warn(...args: unknown[]) {\n    console.log(highlighter.warn(args.join(\" \")))\n  },\n  info(...args: unknown[]) {\n    console.log(highlighter.info(args.join(\" \")))\n  },\n  success(...args: unknown[]) {\n    console.log(highlighter.success(args.join(\" \")))\n  },\n  log(...args: unknown[]) {\n    console.log(args.join(\" \"))\n  },\n  break() {\n    console.log(\"\")\n  },\n}\n","import { highlighter } from \"@/src/utils/highlighter\"\nimport { logger } from \"@/src/utils/logger\"\nimport { z } from \"zod\"\n\nexport function handleError(error: unknown) {\n  logger.error(\n    `Something went wrong. Please check the error below for more details.`\n  )\n  logger.error(`If the problem persists, please open an issue on GitHub.`)\n  logger.error(\"\")\n  if (typeof error === \"string\") {\n    logger.error(error)\n    logger.break()\n    process.exit(1)\n  }\n\n  if (error instanceof z.ZodError) {\n    logger.error(\"Validation failed:\")\n    for (const [key, value] of Object.entries(error.flatten().fieldErrors)) {\n      logger.error(`- ${highlighter.info(key)}: ${value}`)\n    }\n    logger.break()\n    process.exit(1)\n  }\n\n  if (error instanceof Error) {\n    logger.error(error.message)\n    logger.break()\n    process.exit(1)\n  }\n\n  logger.break()\n  process.exit(1)\n}\n","import { promises as fs } from \"fs\"\nimport { tmpdir } from \"os\"\nimport path from \"path\"\nimport {\n  registryItemCssVarsSchema,\n  registryItemTailwindSchema,\n} from \"@/src/registry/schema\"\nimport { Config } from \"@/src/utils/get-config\"\nimport { TailwindVersion } from \"@/src/utils/get-project-info\"\nimport { highlighter } from \"@/src/utils/highlighter\"\nimport { spinner } from \"@/src/utils/spinner\"\nimport deepmerge from \"deepmerge\"\nimport objectToString from \"stringify-object\"\nimport { type Config as TailwindConfig } from \"tailwindcss\"\nimport {\n  ArrayLiteralExpression,\n  ObjectLiteralExpression,\n  Project,\n  PropertyAssignment,\n  QuoteKind,\n  ScriptKind,\n  SyntaxKind,\n  VariableStatement,\n} from \"ts-morph\"\nimport { z } from \"zod\"\n\nexport type UpdaterTailwindConfig = Omit<TailwindConfig, \"plugins\"> & {\n  // We only want string plugins for now.\n  plugins?: string[]\n}\n\nexport async function updateTailwindConfig(\n  tailwindConfig:\n    | z.infer<typeof registryItemTailwindSchema>[\"config\"]\n    | undefined,\n  config: Config,\n  options: {\n    silent?: boolean\n    tailwindVersion?: TailwindVersion\n  }\n) {\n  if (!tailwindConfig) {\n    return\n  }\n\n  options = {\n    silent: false,\n    tailwindVersion: \"v3\",\n    ...options,\n  }\n\n  // No tailwind config in v4.\n  if (options.tailwindVersion === \"v4\") {\n    return\n  }\n\n  const tailwindFileRelativePath = path.relative(\n    config.resolvedPaths.cwd,\n    config.resolvedPaths.tailwindConfig\n  )\n  const tailwindSpinner = spinner(\n    `Updating ${highlighter.info(tailwindFileRelativePath)}`,\n    {\n      silent: options.silent,\n    }\n  ).start()\n  const raw = await fs.readFile(config.resolvedPaths.tailwindConfig, \"utf8\")\n  const output = await transformTailwindConfig(raw, tailwindConfig, config)\n  await fs.writeFile(config.resolvedPaths.tailwindConfig, output, \"utf8\")\n  tailwindSpinner?.succeed()\n}\n\nexport async function transformTailwindConfig(\n  input: string,\n  tailwindConfig: UpdaterTailwindConfig,\n  config: Config\n) {\n  const sourceFile = await _createSourceFile(input, config)\n  // Find the object with content property.\n  // This is faster than traversing the default export.\n  // TODO: maybe we do need to traverse the default export?\n  const configObject = sourceFile\n    .getDescendantsOfKind(SyntaxKind.ObjectLiteralExpression)\n    .find((node) =>\n      node\n        .getProperties()\n        .some(\n          (property) =>\n            property.isKind(SyntaxKind.PropertyAssignment) &&\n            property.getName() === \"content\"\n        )\n    )\n\n  // We couldn't find the config object, so we return the input as is.\n  if (!configObject) {\n    return input\n  }\n\n  const quoteChar = _getQuoteChar(configObject)\n\n  // Add darkMode.\n  addTailwindConfigProperty(\n    configObject,\n    {\n      name: \"darkMode\",\n      value: \"class\",\n    },\n    { quoteChar }\n  )\n\n  // Add Tailwind config plugins.\n  tailwindConfig.plugins?.forEach((plugin) => {\n    addTailwindConfigPlugin(configObject, plugin)\n  })\n\n  // Add Tailwind config theme.\n  if (tailwindConfig.theme) {\n    await addTailwindConfigTheme(configObject, tailwindConfig.theme)\n  }\n\n  return sourceFile.getFullText()\n}\n\nfunction addTailwindConfigProperty(\n  configObject: ObjectLiteralExpression,\n  property: {\n    name: string\n    value: string\n  },\n  {\n    quoteChar,\n  }: {\n    quoteChar: string\n  }\n) {\n  const existingProperty = configObject.getProperty(\"darkMode\")\n\n  if (!existingProperty) {\n    const newProperty = {\n      name: property.name,\n      initializer: `[${quoteChar}${property.value}${quoteChar}]`,\n    }\n\n    // We need to add darkMode as the first property.\n    if (property.name === \"darkMode\") {\n      configObject.insertPropertyAssignment(0, newProperty)\n      return configObject\n    }\n\n    configObject.addPropertyAssignment(newProperty)\n\n    return configObject\n  }\n\n  if (existingProperty.isKind(SyntaxKind.PropertyAssignment)) {\n    const initializer = existingProperty.getInitializer()\n    const newValue = `${quoteChar}${property.value}${quoteChar}`\n\n    // If property is a string, change it to an array and append.\n    if (initializer?.isKind(SyntaxKind.StringLiteral)) {\n      const initializerText = initializer.getText()\n      initializer.replaceWithText(`[${initializerText}, ${newValue}]`)\n      return configObject\n    }\n\n    // If property is an array, append.\n    if (initializer?.isKind(SyntaxKind.ArrayLiteralExpression)) {\n      // Check if the array already contains the value.\n      if (\n        initializer\n          .getElements()\n          .map((element) => element.getText())\n          .includes(newValue)\n      ) {\n        return configObject\n      }\n      initializer.addElement(newValue)\n    }\n\n    return configObject\n  }\n\n  return configObject\n}\n\nasync function addTailwindConfigTheme(\n  configObject: ObjectLiteralExpression,\n  theme: UpdaterTailwindConfig[\"theme\"]\n) {\n  // Ensure there is a theme property.\n  if (!configObject.getProperty(\"theme\")) {\n    configObject.addPropertyAssignment({\n      name: \"theme\",\n      initializer: \"{}\",\n    })\n  }\n\n  // Nest all spread properties.\n  nestSpreadProperties(configObject)\n\n  const themeProperty = configObject\n    .getPropertyOrThrow(\"theme\")\n    ?.asKindOrThrow(SyntaxKind.PropertyAssignment)\n\n  const themeInitializer = themeProperty.getInitializer()\n  if (themeInitializer?.isKind(SyntaxKind.ObjectLiteralExpression)) {\n    const themeObjectString = themeInitializer.getText()\n    const themeObject = await parseObjectLiteral(themeObjectString)\n    const result = deepmerge(themeObject, theme, {\n      arrayMerge: (dst, src) => src,\n    })\n    const resultString = objectToString(result)\n      .replace(/\\'\\.\\.\\.(.*)\\'/g, \"...$1\") // Remove quote around spread element\n      .replace(/\\'\\\"/g, \"'\") // Replace `\\\" with \"\n      .replace(/\\\"\\'/g, \"'\") // Replace `\\\" with \"\n      .replace(/\\'\\[/g, \"[\") // Replace `[ with [\n      .replace(/\\]\\'/g, \"]\") // Replace `] with ]\n      .replace(/\\'\\\\\\'/g, \"'\") // Replace `\\' with '\n      .replace(/\\\\\\'/g, \"'\") // Replace \\' with '\n      .replace(/\\\\\\'\\'/g, \"'\")\n      .replace(/\\'\\'/g, \"'\")\n    themeInitializer.replaceWithText(resultString)\n  }\n\n  // Unnest all spread properties.\n  unnestSpreadProperties(configObject)\n}\n\nfunction addTailwindConfigPlugin(\n  configObject: ObjectLiteralExpression,\n  plugin: string\n) {\n  const existingPlugins = configObject.getProperty(\"plugins\")\n\n  if (!existingPlugins) {\n    configObject.addPropertyAssignment({\n      name: \"plugins\",\n      initializer: `[${plugin}]`,\n    })\n\n    return configObject\n  }\n\n  if (existingPlugins.isKind(SyntaxKind.PropertyAssignment)) {\n    const initializer = existingPlugins.getInitializer()\n\n    if (initializer?.isKind(SyntaxKind.ArrayLiteralExpression)) {\n      if (\n        initializer\n          .getElements()\n          .map((element) => {\n            return element.getText().replace(/[\"']/g, \"\")\n          })\n          .includes(plugin.replace(/[\"']/g, \"\"))\n      ) {\n        return configObject\n      }\n      initializer.addElement(plugin)\n    }\n\n    return configObject\n  }\n\n  return configObject\n}\n\nexport async function _createSourceFile(input: string, config: Config | null) {\n  const dir = await fs.mkdtemp(path.join(tmpdir(), \"shadcn-\"))\n  const resolvedPath =\n    config?.resolvedPaths?.tailwindConfig || \"tailwind.config.ts\"\n  const tempFile = path.join(dir, `shadcn-${path.basename(resolvedPath)}`)\n\n  const project = new Project({\n    compilerOptions: {},\n  })\n  const sourceFile = project.createSourceFile(tempFile, input, {\n    // Note: .js and .mjs can still be valid for TS projects.\n    // We can't infer TypeScript from config.tsx.\n    scriptKind:\n      path.extname(resolvedPath) === \".ts\" ? ScriptKind.TS : ScriptKind.JS,\n  })\n\n  return sourceFile\n}\n\nexport function _getQuoteChar(configObject: ObjectLiteralExpression) {\n  return configObject\n    .getFirstDescendantByKind(SyntaxKind.StringLiteral)\n    ?.getQuoteKind() === QuoteKind.Single\n    ? \"'\"\n    : '\"'\n}\n\nexport function nestSpreadProperties(obj: ObjectLiteralExpression) {\n  const properties = obj.getProperties()\n\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i]\n    if (prop.isKind(SyntaxKind.SpreadAssignment)) {\n      const spreadAssignment = prop.asKindOrThrow(SyntaxKind.SpreadAssignment)\n      const spreadText = spreadAssignment.getExpression().getText()\n\n      // Replace spread with a property assignment\n      obj.insertPropertyAssignment(i, {\n        // Need to escape the name with \" so that deepmerge doesn't mishandle the key\n        name: `\"___${spreadText.replace(/^\\.\\.\\./, \"\")}\"`,\n        initializer: `\"...${spreadText.replace(/^\\.\\.\\./, \"\")}\"`,\n      })\n\n      // Remove the original spread assignment\n      spreadAssignment.remove()\n    } else if (prop.isKind(SyntaxKind.PropertyAssignment)) {\n      const propAssignment = prop.asKindOrThrow(SyntaxKind.PropertyAssignment)\n      const initializer = propAssignment.getInitializer()\n\n      if (\n        initializer &&\n        initializer.isKind(SyntaxKind.ObjectLiteralExpression)\n      ) {\n        // Recursively process nested object literals\n        nestSpreadProperties(\n          initializer.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)\n        )\n      } else if (\n        initializer &&\n        initializer.isKind(SyntaxKind.ArrayLiteralExpression)\n      ) {\n        nestSpreadElements(\n          initializer.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)\n        )\n      }\n    }\n  }\n}\n\nexport function nestSpreadElements(arr: ArrayLiteralExpression) {\n  const elements = arr.getElements()\n  for (let j = 0; j < elements.length; j++) {\n    const element = elements[j]\n    if (element.isKind(SyntaxKind.ObjectLiteralExpression)) {\n      // Recursive check on objects within arrays\n      nestSpreadProperties(\n        element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)\n      )\n    } else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) {\n      // Recursive check on nested arrays\n      nestSpreadElements(\n        element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)\n      )\n    } else if (element.isKind(SyntaxKind.SpreadElement)) {\n      const spreadText = element.getText()\n      // Spread element within an array\n      arr.removeElement(j)\n      arr.insertElement(j, `\"${spreadText}\"`)\n    }\n  }\n}\n\nexport function unnestSpreadProperties(obj: ObjectLiteralExpression) {\n  const properties = obj.getProperties()\n\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i]\n    if (prop.isKind(SyntaxKind.PropertyAssignment)) {\n      const propAssignment = prop as PropertyAssignment\n      const initializer = propAssignment.getInitializer()\n\n      if (initializer && initializer.isKind(SyntaxKind.StringLiteral)) {\n        const value = initializer\n          .asKindOrThrow(SyntaxKind.StringLiteral)\n          .getLiteralValue()\n        if (value.startsWith(\"...\")) {\n          obj.insertSpreadAssignment(i, { expression: value.slice(3) })\n          propAssignment.remove()\n        }\n      } else if (initializer?.isKind(SyntaxKind.ObjectLiteralExpression)) {\n        unnestSpreadProperties(initializer as ObjectLiteralExpression)\n      } else if (\n        initializer &&\n        initializer.isKind(SyntaxKind.ArrayLiteralExpression)\n      ) {\n        unsetSpreadElements(\n          initializer.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)\n        )\n      }\n    }\n  }\n}\n\nexport function unsetSpreadElements(arr: ArrayLiteralExpression) {\n  const elements = arr.getElements()\n  for (let j = 0; j < elements.length; j++) {\n    const element = elements[j]\n    if (element.isKind(SyntaxKind.ObjectLiteralExpression)) {\n      // Recursive check on objects within arrays\n      unnestSpreadProperties(\n        element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)\n      )\n    } else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) {\n      // Recursive check on nested arrays\n      unsetSpreadElements(\n        element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)\n      )\n    } else if (element.isKind(SyntaxKind.StringLiteral)) {\n      const spreadText = element.getText()\n      // check if spread element\n      const spreadTest = /(?:^['\"])(\\.\\.\\..*)(?:['\"]$)/g\n      if (spreadTest.test(spreadText)) {\n        arr.removeElement(j)\n        arr.insertElement(j, spreadText.replace(spreadTest, \"$1\"))\n      }\n    }\n  }\n}\n\nasync function parseObjectLiteral(objectLiteralString: string): Promise<any> {\n  const sourceFile = await _createSourceFile(\n    `const theme = ${objectLiteralString}`,\n    null\n  )\n\n  const statement = sourceFile.getStatements()[0]\n  if (statement?.getKind() === SyntaxKind.VariableStatement) {\n    const declaration = (statement as VariableStatement)\n      .getDeclarationList()\n      ?.getDeclarations()[0]\n    const initializer = declaration.getInitializer()\n    if (initializer?.isKind(SyntaxKind.ObjectLiteralExpression)) {\n      return await parseObjectLiteralExpression(initializer)\n    }\n  }\n\n  throw new Error(\"Invalid input: not an object literal\")\n}\n\nfunction parseObjectLiteralExpression(node: ObjectLiteralExpression): any {\n  const result: any = {}\n  for (const property of node.getProperties()) {\n    if (property.isKind(SyntaxKind.PropertyAssignment)) {\n      const name = property.getName().replace(/\\'/g, \"\")\n      if (\n        property.getInitializer()?.isKind(SyntaxKind.ObjectLiteralExpression)\n      ) {\n        result[name] = parseObjectLiteralExpression(\n          property.getInitializer() as ObjectLiteralExpression\n        )\n      } else if (\n        property.getInitializer()?.isKind(SyntaxKind.ArrayLiteralExpression)\n      ) {\n        result[name] = parseArrayLiteralExpression(\n          property.getInitializer() as ArrayLiteralExpression\n        )\n      } else {\n        result[name] = parseValue(property.getInitializer())\n      }\n    }\n  }\n  return result\n}\n\nfunction parseArrayLiteralExpression(node: ArrayLiteralExpression): any[] {\n  const result: any[] = []\n  for (const element of node.getElements()) {\n    if (element.isKind(SyntaxKind.ObjectLiteralExpression)) {\n      result.push(\n        parseObjectLiteralExpression(\n          element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)\n        )\n      )\n    } else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) {\n      result.push(\n        parseArrayLiteralExpression(\n          element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)\n        )\n      )\n    } else {\n      result.push(parseValue(element))\n    }\n  }\n  return result\n}\n\nfunction parseValue(node: any): any {\n  switch (node.getKind()) {\n    case SyntaxKind.StringLiteral:\n      return node.getText()\n    case SyntaxKind.NumericLiteral:\n      return Number(node.getText())\n    case SyntaxKind.TrueKeyword:\n      return true\n    case SyntaxKind.FalseKeyword:\n      return false\n    case SyntaxKind.NullKeyword:\n      return null\n    case SyntaxKind.ArrayLiteralExpression:\n      return node.getElements().map(parseValue)\n    case SyntaxKind.ObjectLiteralExpression:\n      return parseObjectLiteralExpression(node)\n    default:\n      return node.getText()\n  }\n}\n\nexport function buildTailwindThemeColorsFromCssVars(\n  cssVars: z.infer<typeof registryItemCssVarsSchema>\n) {\n  const result: Record<string, any> = {}\n\n  for (const key of Object.keys(cssVars)) {\n    const parts = key.split(\"-\")\n    const colorName = parts[0]\n    const subType = parts.slice(1).join(\"-\")\n\n    if (subType === \"\") {\n      if (typeof result[colorName] === \"object\") {\n        result[colorName].DEFAULT = `hsl(var(--${key}))`\n      } else {\n        result[colorName] = `hsl(var(--${key}))`\n      }\n    } else {\n      if (typeof result[colorName] !== \"object\") {\n        result[colorName] = { DEFAULT: `hsl(var(--${colorName}))` }\n      }\n      result[colorName][subType] = `hsl(var(--${key}))`\n    }\n  }\n\n  // Remove DEFAULT if it's not in the original cssVars\n  for (const [colorName, value] of Object.entries(result)) {\n    if (\n      typeof value === \"object\" &&\n      value.DEFAULT === `hsl(var(--${colorName}))` &&\n      !(colorName in cssVars)\n    ) {\n      delete value.DEFAULT\n    }\n  }\n\n  return result\n}\n","import ora, { type Options } from \"ora\"\n\nexport function spinner(\n  text: Options[\"text\"],\n  options?: {\n    silent?: boolean\n  }\n) {\n  return ora({\n    text,\n    isSilent: options?.silent,\n  })\n}\n"]}